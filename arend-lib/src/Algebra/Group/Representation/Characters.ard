\import Algebra.Group
\import Algebra.Group.Examples
\import Algebra.Group.Representation.Category
\import Algebra.Group.Representation.Irreducible
\import Algebra.Group.Representation.MaschkeLemma
\import Algebra.Group.Representation
\import Algebra.Linear.BilinearForms
\import Algebra.Linear.Matrix
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.ModuleCategory
\import Algebra.Module.LinearMap
\import Algebra.Module.PowerLModule
\import Algebra.Module.Trace
\import Algebra.Monoid
\import Algebra.Ring
\import Algebra.Semiring
\import Category
\import Equiv
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Set.Fin

\func toMatrix_zro {R : Ring}{U V : LModule R}{lv : Array V}(lu : Array U)(bv : V.IsBasis lv)(f : LinearMap U V)(f-zro : isZeroMap f) :
  LinearMap.toMatrix lu bv f = AbGroup.zro {MatrixAbGroup R lu.len lv.len} => {?}

-- {R : Ring} {U V : LModule R} {lv : Array V} (lu : Array U) (bv : V.IsBasis lv) (f : LinearMap U V) : Matrix R lu.len lv.len

\class InvFieldWithInvertible (G : FinGroup) \extends FieldWithInvolution{
  | |G|^-1 : E
  | |G|-inv : natCoef G.finCard * |G|^-1 = ide
}

\func Character {R : Ring}{G : Group}(E : LRepres R G)
                {lv : Array E} (bv : E.IsBasis lv)
                (g : G) : R => Trace (LinearMap.toMatrix lv bv (E.toLinearMap g))
  \where {
    \protected \func chi (g : G) : R => Character E bv g

    \func of-1 : chi G.ide = R.natCoef lv.len => unfold chi (unfold Character (rewrite (Matrix-of-1, Trace-ide) idp))

    \func Matrix-of-1 : LinearMap.toMatrix lv bv (E.toLinearMap G.ide) = MatrixRing.ide => rewrite (E.toLinearMap-ide, LinearMap.toMatrix_ide) idp
  }

\func Funcs(G : FinGroup)(F : InvFieldWithInvertible G) : LModule F => PowerLModule G (RingLModule F)

\func FuncForm{G : FinGroup}(F : InvFieldWithInvertible G)(f g : G -> F) => |G|^-1 F.* F.FinSum (\lam x => f x F.* g (inverse x))

\func FuncFormAdd {G : FinGroup}(F : InvFieldWithInvertible G) : BilinearMap (Funcs G F) (Funcs G F) (RingLModule F) \cowith
  | func => FuncForm F
  | linear-left {b} => \new LinearMap {
    | func-+ {a} {c} => FuncFormAddLeft a c b
    | func-*c {r}{f} => FuncFormScalarLeft f b r
  }
  | linear-right {b} => \new LinearMap {
    | func-+ {a}{c} => FuncFormAddRight b a c
    | func-*c {r} {f} => FuncFormScalarRight b f r
  }
  \where {
    \protected \func FuncFormScalarLeft (f g : Funcs G F)(r : F) : FuncForm F (r LModule.*c {Funcs G F} f) g =
    r F.* FuncForm F f g => unfold FuncForm (rewrite (inv F.*-assoc ,F.*-comm {r} {|G|^-1}, pmap (\lam z => |G|^-1 * z) (unfold helper')) equation)
      \where {
        \protected \func helper' : F.FinSum (\lam x => (r * f x) * (g (G.inverse x))) = r F.* F.FinSum (\lam x => (f x) * (g (G.inverse x)))
          => \case F.FinSum_char (\lam x => (r * f x) * (g (G.inverse x))) \with {
            | inP (e, p) => \case F.FinSum_char2 (\lam x => (f x) * (g (G.inverse x))) e \with {
              | p1 => rewrite (p, p1, BigSumScalarLeft e) idp
            }
          }
        \protected \func BigSumScalarLeft (e : Equiv {Fin G.finCard} {G}) :
          F.BigSum (\lam j => r F.* f (e j) F.* g (G.inverse (e j))) = r F.* F.BigSum (\lam j => f (e j) F.* g (G.inverse (e j)))
          => rewrite (BigSumScalarLeftHelp e, BigSumScalarLeft' G.finCard (\lam j => f (e j) F.* g (G.inverse (e j)))) idp
        \protected \lemma BigSumScalarLeftHelp(e : Equiv {Fin G.finCard} {G}) :
          F.BigSum (\lam j => r F.* f (e j) F.* g (G.inverse (e j))) = F.BigSum (\lam j => r * (f (e j) * g (G.inverse (e j))))
          => Trace-prod.BigSum-ext (\lam i => F.*-assoc)
        \protected \func BigSumScalarLeft' (n : Nat)(a : Array F n)(r : F) :
          F.BigSum (\lam j => r * (a j)) = r * (F.BigSum a) => inv $ F.BigSum-ldistr
      }


    \protected \func FuncFormAddLeft (f g h : Funcs G F) : FuncForm F (f LModule.+ g) h =
    FuncForm F f h F.+ FuncForm F g h => rewrite (inv $ ldistr, pmap (\lam z => |G|^-1 F.* z) (unfold helper')) idp
      \where {
        \protected \func helper' : F.FinSum (\lam x => (f x F.+ g x) F.* h (inverse x)) =
        F.FinSum (\lam x => f x F.* h(inverse x)) F.+ F.FinSum (\lam x => g x F.* h(inverse x)) => \case AbMonoid.FinSum_char (\lam x => (f x F.+ g x) F.* h (inverse x)) \with {
          | inP (e, p) => \case AbMonoid.FinSum_char2 (\lam x => f x F.* h(inverse x)) e \with {
            | p1 => \case AbMonoid.FinSum_char2(\lam x => g x F.* h(inverse x)) e \with {
              | p2 => rewrite (p, p1, p2, BigSumAddLeft e) idp
            }
          }
        }
        \protected \func BigSumAddLeft (e : Equiv {Fin G.finCard} {G}) :
          F.BigSum (\lam j => (f (e j) F.+ g (e j)) F.* h (G.inverse (e j))) =
          F.BigSum (\lam j => f (e j) F.* h (G.inverse (e j))) F.+ F.BigSum (\lam j => g (e j) F.* h (G.inverse (e j)))
          => BigSumAddLeft' G.finCard (\lam j => f (e j)) (\lam j => g (e j)) (\lam j => h (G.inverse (e j)))
        \protected \func BigSumAddLeft' (n : Nat) (a b c : Array F n) :
          F.BigSum (\lam j => ((a j) + (b j)) F.* (c j)) = F.BigSum (\lam j => (a j) * (c j)) + F.BigSum (\lam j => (b j) * (c j)) \elim n
          | 0 => unfold AddMonoid.BigSum (inv F.zro-right)
          | suc n => unfold AddMonoid.BigSum (rewrite (F.rdistr, BigSumAddLeft' n (\lam j => a (suc j)) (\lam j => b (suc j)) (\lam j => c (suc j))) equation)
      }

    \protected \func FuncFormAddRight (f g h : Funcs G F) : FuncForm F f (g LModule.+ h) =
    FuncForm F f g F.+ FuncForm F f h => rewrite (inv $ ldistr, pmap (\lam z => |G|^-1 F.* z) (unfold helper')) idp
      \where {
        \protected \func helper' : F.FinSum (\lam x => (f x) F.* (g (inverse x) + h (inverse x))) =
        F.FinSum (\lam x => f x F.* g(inverse x)) F.+ F.FinSum (\lam x => f x F.* h(inverse x)) => \case F.FinSum_char (\lam x => (f x) F.* (g (inverse x) + h (inverse x))) \with {
          | inP (e, p) => \case F.FinSum_char2 (\lam x => f x F.* g(inverse x)) e \with {
            | p1 => \case F.FinSum_char2 (\lam x => f x F.* h(inverse x)) e \with {
              | p2 => rewrite (p, p1, p2, BigSumAddRight e) idp
            }
          }
        }

        \protected \func BigSumAddRight (e : Equiv {Fin G.finCard} {G}) :
          F.BigSum (\lam j => f (e j) F.* (g (G.inverse(e j)) + h (G.inverse (e j)))) =
          F.BigSum (\lam j => f (e j) F.* (g (G.inverse(e j)))) +  F.BigSum (\lam j => f (e j) F.* h (G.inverse (e j)))
          => BigSumAddRight' G.finCard (\lam j => f (e j))(\lam j => g (G.inverse(e j)))(\lam j => h (G.inverse(e j)))

        \protected \func BigSumAddRight' (n : Nat) (a b c : Array F n) :
          F.BigSum (\lam j => (a j) F.* ((b j) + (c j))) =
          F.BigSum (\lam j => (a j) * (b j)) + F.BigSum (\lam j => (a j) * (c j))  \elim n
          | 0 => unfold F.BigSum (inv F.zro-right)
          | suc n => unfold F.BigSum (rewrite (F.ldistr, BigSumAddRight' n (\lam j => a (suc j)) (\lam j => b (suc j)) (\lam j => c (suc j))) equation)

      }

    \protected \func FuncFormScalarRight (f g : Funcs G F)(r : F) : FuncForm F f (r LModule.*c {Funcs G F} g) =
    r F.* FuncForm F f g => unfold FuncForm (rewrite (inv $ F.*-assoc {r}, F.*-comm {r} {|G|^-1}, pmap (\lam z => |G|^-1 * z) (unfold helper')) equation) -- unfold FuncForm (rewrite (inv F.*-assoc ,F.*-comm {r} {|G|^-1}, pmap (\lam z => |G|^-1 * z) (unfold helper')) equation)
      \where {
        \protected \func helper' : F.FinSum (\lam x => f x * (r * (g (G.inverse x)))) = r F.* F.FinSum (\lam x => (f x) * (g (G.inverse x)))
          => \case F.FinSum_char (\lam x => f x * (r * (g (G.inverse x)))) \with {
            | inP (e, p) => \case F.FinSum_char2 (\lam x => (f x) * (g (G.inverse x))) e \with {
              | p1 => rewrite (p, p1, BigSumScalarRight e) idp
            }
          }
        \protected \func BigSumScalarRight (e : Equiv {Fin G.finCard} {G}) :
          F.BigSum (\lam j => f (e j) F.* (r F.* g (G.inverse (e j)))) = r F.* F.BigSum (\lam j => f (e j) F.* g (G.inverse (e j)))
          => rewrite (BigSumScalarRightHelp e, BigSumScalarRight' G.finCard (\lam j => f (e j) F.* g (G.inverse (e j)))) idp --  rewrite (BigSumScalarRightHelp e, BigSumScalarRight' G.finCard (\lam j => f (e j) F.* g (G.inverse (e j)))) idp
        \protected \lemma BigSumScalarRightHelp(e : Equiv {Fin G.finCard} {G}) :
          F.BigSum (\lam j => f (e j) F.* (r * g (G.inverse (e j)))) = F.BigSum (\lam j => r * (f (e j) * g (G.inverse (e j))))
          => Trace-prod.BigSum-ext (\lam i => equation)
        \protected \func BigSumScalarRight' (n : Nat)(a : Array F n)(r : F) :
          F.BigSum (\lam j => r * (a j)) = r * (F.BigSum a) => inv $ F.BigSum-ldistr
      }
  }

\func GroupFieldFunctions (G : FinGroup)(F : InvFieldWithInvertible G) : SesquilinearSpace
  => BilinearSpace {F}(PowerLModule G (RingLModule F)) (FuncFormAdd F)
  \where {
    \open SesquilinearSpace
    \func OrthogonalityCondition {f g : GroupFieldFunctions G F}
                                 (p : F.FinSum (\lam x => f x F.* g (inverse x)) = F.zro) :
      f SesquilinearSpace.orthogonal {GroupFieldFunctions G F} g =>
      unfold (orthogonal) (unfold (B) (unfold (FuncForm)
        (rewrite (inv $ ide-left {_}{FuncForm F f g}, inv $ |G|-inv {F}, *-assoc) {?})))
  }


\func MatrixElements {G : FinGroup}{F : InvFieldWithInvertible G}{E : LRepres F G}
                     {l : Array E}(l-bas : E.IsBasis l)(i j : Fin l.len) : GroupFieldFunctions G F =>
  \lam g => (LinearMap.toMatrix l l-bas (E.toLinearMap g)) i j

{- | For two non-isomorphic irreducible G-representations the elements  -}
\func OrthogonalityRelation {G : FinGroup}{F : InvFieldWithInvertible G}{E1 E2 : LRepres F G}
                            {E1-irr : Irreducible E1}
                            {E2-irr : Irreducible E2}
                            {l1 : Array E1}(l1-bas : E1.IsBasis l1)
                            {l2 : Array E2}(l2-bas : E2.IsBasis l2)
                            (i j : Fin l1.len)(k h : Fin l2.len)
                            {not-eq : Not(Iso {RepresentationCat F G} {E1}{E2})} :
    (MatrixElements l1-bas i j) SesquilinearSpace.orthogonal {GroupFieldFunctions G F} (MatrixElements l2-bas k h)
  => GroupFieldFunctions.OrthogonalityCondition {G}{F}{MatrixElements l1-bas i j}{MatrixElements l2-bas k h}
    (transport (\lam z => z = F.zro) (inv rewriteBilinearform')
      (extract_zero (LinearMap.toMatrix l1 l2-bas (SumOverGroup Ejk-lin)) MatrixOrthogonality i h))
  \where {
    \func B => SesquilinearSpace.B {GroupFieldFunctions G F}
    \func Ejk : Matrix F l1.len l2.len => mkMatrix \lam a b => \case decideEq a j \with {
      | no n => F.zro
      | yes e => \case decideEq b k \with {
        | no n => F.zro
        | yes e1 => F.ide
      }
    }
    \func Ejk-lin : LinearMap E1 E2 => LinearMap.toLinearMap l1-bas l2 Ejk

    \func rewriteBilinearform' :
      F.FinSum (\lam g => (MatrixElements l1-bas i j g) * (MatrixElements l2-bas k h (inverse g))) =
      (LinearMap.toMatrix l1 l2-bas (SumOverGroup Ejk-lin)) i h => {?}

    \func rewriteBilinearform :
      B (MatrixElements l1-bas i j) (MatrixElements l2-bas k h) =
      (LinearMap.toMatrix l1 l2-bas (SumOverGroup Ejk-lin)) i h => {?}

    \func MatrixOrthogonality :
      (LinearMap.toMatrix l1 l2-bas (SumOverGroup Ejk-lin)) = AbGroup.zro {MatrixAbGroup F l1.len l2.len}
      => toMatrix_zro l1 l2-bas (SumOverGroup Ejk-lin) (SumOverGroupSchur {F} {G} {E1}{E2} E1-irr E2-irr not-eq Ejk-lin)


    \func extract_zero (A : Matrix F l1.len l2.len)
                       (p : A = AbGroup.zro {MatrixAbGroup F l1.len l2.len})
                       (x : Fin l1.len)(y : Fin l2.len) : A x y = F.zro => transport (\lam z => z x y = F.zro) (inv p) idp
  }